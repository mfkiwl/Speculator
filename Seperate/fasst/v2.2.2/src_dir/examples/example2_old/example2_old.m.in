% Exemple 2 shows how to use FASST in the anechoic case with 8 channels microphone probe and two speakers.
% FASST model is initialized as follow :
% Source paramater Wex : original source spectrogram
% Source paramater Hex : Identity matrix
% Source paramater A : Steering vector in the main direction of arrival
% Source paramater adaptability : free

% Source images are assumed known and mixed together
% Original source are assumed known
% The main direction of arrival for each source is assumed known 
% (it should be estimated with a localization tool on the true source images)

% Cleaning
clear all;
close all;

% Add FASST directory to PATH
FASST_MATLAB_DIR = '@FASST_MATLAB_DIR@';

if ~exist('fasst_writeXML', 'file')
    addpath(FASST_MATLAB_DIR);
end

% Add PEASS PATH to MATLAB
PEASS_BACk_END = @PEASS_BACk_END@;
PEASS_PATH = '@PEASS_PATH@';
if(PEASS_BACk_END ==1)
    addpath(genpath(PEASS_PATH));
    peassOutputDir = './peass/';
    mkdir(peassOutputDir);
end

% Add BSS EVAL PATH to MATLAB
BSS_EVAL_BACK_END = @BSS_EVAL_BACK_END@;
BSS_EVAL_PATH = '@BSS_EVAL_PATH@';
if(BSS_EVAL_BACK_END == 1)
    addpath(BSS_EVAL_PATH)
end

% Add tools PATH to MATLAB
addpath('../tools')

%create necessary folders
results_dir = 'results/'; % results folder
tmp_dir    = 'temp/';    % temporary folder (intermediate files generated by FASST)

if ~exist(results_dir, 'dir')
    mkdir(results_dir);
end
if ~exist(tmp_dir, 'dir')
    mkdir(tmp_dir);
end

%% ------------------------------------------------------------------------
%                      Mixture parameters
%--------------------------------------------------------------------------

% microphones array positions
ppfMicPos = ... % All microphones are supposed to be omnidirectionnal !
    [0.037 0.056 -0.038;
    -0.034 0.056 0.038;
    -0.056 0.037 -0.038;
    -0.056 -0.034 0.038;
    -0.037 -0.056 -0.038;
    0.034 -0.056 0.038;
    0.056 -0.037 -0.038;
    0.056 0.034 0.038;
    ];

%% Read audio files and compute mixture
% male1. wav and male2.wav are real records of speakers using array of
% microphones described above by ppfMicPos

iFs=16000;
wavImagNames = {'src_imag_1.wav','src_imag_2.wav'};
wavOrigNames = {'male_s1.wav','female_s1.wav'};
for j=1:length(wavImagNames)
    [Src_Image(j,:,:),~] = audioread(wavImagNames{j});
    [Src_orig(j,:),~] = audioread(wavOrigNames{j});
end

nsampl = size(Src_Image,2);
% compute mixture
x=squeeze(sum(Src_Image,1));
mixture_wavname= [results_dir 'mixture.wav'];
audiowrite(mixture_wavname,x,iFs)

[nbSamples_Mix,I] = size(x);

%% ------------------------------------------------------------------------
%                      FASST parameters
%--------------------------------------------------------------------------

% Mixture parameters
J = length(wavImagNames);                    % Number of sources
MixtureType = 'conv';     % Mixture type : "inst" (instantaneaous mixture) / "conv" (convolutive mixture : take into account time propagation and reflexions)

% Models parameters
K = 128;                   % NFM rank

% Time-frequency transform
transformType = 'STFT';   %{'STFT','ERB'}
wlen          = 1024;     % window length (frame length in time domain) - % should be multiple of 4 for STFT and multiple of 2 for ERB
nbin_ERB      = 128;       % number of frequency coefficient for ERB transform type

% Number of iteration for sources models estimation
Niteration_EM = 50;

% Activate / desactivate simulated annealing
bSimulatedAnnealing = 1;

switch (transformType)
    
    case 'STFT'
        nbin = wlen/2 +1;
        freq_band_centers = linspace(0.001,iFs/2,nbin);
        
    case 'ERB'
        
        nbin= nbin_ERB;   % number of frequency bins (for ERB)
        
        % extracted from qerbt.m (author : emmanuel Vincent) : same implementation as in FASST software
        
        emax=9.26*log(.00437*iFs/2+1);
        e=(0:nbin-1)*emax/(nbin-1);
        freq_band_centers=(exp(e/9.26)-1)/.00437;
        freq_band_centers(1)=0.001; % to avoid "0" leading to non invertible matrices (FASST) when using spatial anechoÃ¯c model for some sources
        
        
    otherwise
        error([ '[' functionName '] ' 'Requested transform type not available']);
end

%compute number of frames
N = ceil(nbSamples_Mix/wlen*2); % number of frames

%% ------------------------------------------------------------------------
%                       user informations
%--------------------------------------------------------------------------

% Initialization models
spatial_information_type = 'Direction';    % Direction / Default / Identity
spectral_information_type = 'Src_Orig_Spectrogram';     % VQ_Src_Images / Default / Src_Orig_Spectrogram

% estimated directions for each speaker (using mbss locate software)
estimatedDirections = [];
estimatedDirections{1} = [-45,0];  % [azimuth, elevation] _degrees
estimatedDirections{2} = [45,0];  % [azimuth, elevation] _degrees

% rank of A corresponds to number of directions concerned by source j
A_rank = zeros(1,J);
for j=1:J
    A_rank(j) = size(estimatedDirections{j},1);
end

%% ------------------------------------------------------------------------
%                      Models default initialization
%--------------------------------------------------------------------------

disp('> FASST Initialization');

sources=[];

for j = 1:J
    % **** Sources models parameters **** :
    % "mixingType" (mixture type): "inst" (instantaneaous mixture) / "conv" (convolutive mixture : take into account time propagation and reflexion)
    % "adaptability" (FASST adaptation mode) : "fixed" (no adaptation) / "free" (model adapted by FASST)
    % "data" : initialization values for data models
    
    sources{j}.name = ['EstimatedSource_',num2str(j)];
    
    % spatial covariance model
    sources{j}.A.mixingType = MixtureType;
    % default initialization
    sources{j}.A.adaptability = 'free';
    switch(sources{j}.A.mixingType)
        
        case 'inst' % instantaneous mixture (gain values in [0 1])
            sources{j}.A.data = rand(I,1);
        case 'conv'
            switch (spatial_information_type)
                
                case 'Default'
                    % default init
                    sources{j}.A.data = randn(I,A_rank(j),nbin);
                    
                case 'Direction'
                    % Init from Direction
                    sources{j}.A.data = randn(I,A_rank(j),nbin); % default initialization
                    sources{j}.A.data = computeSteeringVectorFromDirection(sources{j}.A.data,estimatedDirections{j},ppfMicPos,freq_band_centers);
                    
                case 'Identity'
                    
                    sources{j}.A.data = repmat(eye(I),1,1,nbin);
                    
                otherwise
                    error('Wrong type of spatial information : spatial_information_type = %s => check your parameters !',spatial_information_type);
            end
            
        otherwise
            error('Wrong type of mixture : sources{%d}.A.mixingType = %s => check your parameters !',j,sources{j}.A.mixingType);
    end
    
    % lvl one spectral paterns (Wex) and lvl one time activation paterns
    % applied to spectral paterns (Hex)
    
    sources{j}.Wex.adaptability = 'free';
    sources{j}.Hex.adaptability = 'free';
    
    
    switch(spectral_information_type)
        
        case 'Default' % default initialization
            sources{j}.Wex.data = 0.75 * abs(randn(nbin, K)) + 0.25 * ones(nbin, K);
            sources{j}.Hex.data = 0.75 * abs(randn(K, N)) + 0.25 * ones(K, N);
            
        case 'VQ_Src_Images'
            % learn dictionnary of spectral patterns from current source images (max energy channel)
            [~,MaxEnergyChannelId]=max(mean(squeeze(Src_Image(j,:,:)).^2,1));
            Vj = stft_multi(squeeze(Src_Image(j,:,MaxEnergyChannelId)),wlen);
            Vj = abs(Vj).^2;
            sources{j}.Wex.data = VQ(Vj.^0.5, log2(K)).^2;
            
            K_Prim = size(sources{j}.Wex.data,2); % new NMF order after VQ
            sources{j}.Hex.data = 0.75 * abs(randn(K_Prim, N)) + 0.25 * ones(K_Prim, N);
            
            fprintf('NMF_Order source %d : %d (requested NMF_Order was %d)\n',j,K_Prim,K);
            clear Vj;
        
        case 'Src_Orig_Spectrogram'
                sources{j}.Wex.data = abs(stft_multi(Src_orig(j,:),wlen)).^2;
                sources{j}.Hex.data = eye(N);   % <=> Identity (Hex is encoded in Wex in this use case)  
        otherwise
            error(' spectral_information_type set to incorrect value : %s => check your parameters',spectral_information_type);
    end
    
    
    % **** sources separations : wiener filter parameters *****
    sources{j}.wiener.a = 0;% Default = 0 (dB)
    sources{j}.wiener.b = 0;% Default = 0 (inside [0,1])
    sources{j}.wiener.c1 = 0;% Default = 0 (Positive integer)
    sources{j}.wiener.c2 = 0;% Default = 0 (Positive integer)
    sources{j}.wiener.d = -Inf;% Default = -Inf (dB)
end



%% ------------------------------------------------------------------------
%                      Call FASST executables
%--------------------------------------------------------------------------

% Define FASST data structure
if strcmp(transformType, 'STFT')
    FASST_data.tfr_type = 'STFT'; % Optional (Default = 'STFT), ERB can also be used
    FASST_data.wlen = wlen;
else % 'ERB'
    FASST_data.tfr_type = 'ERB'; %
    FASST_data.nbin = nbin;
    FASST_data.wlen = wlen;
end
FASST_data.sources = sources;
FASST_data.iterations = Niteration_EM;

%% Write parameters to XML
xml_fname = [tmp_dir 'sources.xml'];
fasst_writeXML(xml_fname, FASST_data);


%% ------------------------------------------------------------------------
%                      Call FASST executables
%--------------------------------------------------------------------------
disp('> FASST execution');

disp('Input time-frequency representation');
fasst_compute_mixture_covariance_matrix(mixture_wavname, xml_fname, tmp_dir)

% Run EM algorithm
disp('Estimate sources models');
if(bSimulatedAnnealing)
    fasst_estimate_source_parameters(xml_fname, tmp_dir, [xml_fname '.new'])
else
    fasst_estimate_source_parameters(xml_fname, tmp_dir, [xml_fname '.new'],'-NoSimAnn')
end

disp('Computation of the spatial source images');
fasst_estimate_sources(mixture_wavname, [xml_fname '.new'], tmp_dir, results_dir)

% Delete temporary folder
rmdir(tmp_dir,'s')

%% PEASS back-end
if(PEASS_BACk_END)
    for j=1:J
        originalFiles = {...
            ['./' 'src_imag_' num2str(j) '.wav'];...
            };
        estimateFile =  [results_dir sources{j}.name '.wav'];
        
        %%%%%%%%%%%%%
        % Set options
        %%%%%%%%%%%%%
        options.destDir = peassOutputDir;
        options.segmentationFactor = 1; % increase this integer if you experienced "out of memory" problems
        
        %%%%%%%%%%%%%%%%%%%%
        % Call main function
        %%%%%%%%%%%%%%%%%%%%
        res = PEASS_ObjectiveMeasure(originalFiles,estimateFile,options);
        
        %%%%%%%%%%%%%%%%%
        % Display results
        %%%%%%%%%%%%%%%%%
        fprintf('************************\n');
        fprintf(['* EVALUATION FOR SOURCE' num2str(j) '*\n']);
        fprintf('************************\n');
        
        fprintf('************************\n');
        fprintf('* INTERMEDIATE RESULTS *\n');
        fprintf('************************\n');
        
        fprintf('The decomposition has been generated and stored in:\n');
        cellfun(@(s)fprintf(' - %s\n',s),res.decompositionFilenames);
        
        fprintf('The ISR, SIR, SAR and SDR criteria computed with the new decomposition are:\n');
        fprintf(' - SDR = %.1f dB\n - ISR = %.1f dB\n - SIR = %.1f dB\n - SAR = %.1f dB\n',...
            res.SDR,res.ISR,res.SIR,res.SAR);
        
        fprintf('The audio quality (PEMO-Q) criteria computed with the new decomposition are:\n');
        fprintf(' - qGlobal = %.3f\n - qTarget = %.3f\n - qInterf = %.3f\n - qArtif = %.3f\n',...
            res.qGlobal,res.qTarget,res.qInterf,res.qArtif);
        
        fprintf('*************************\n');
        fprintf('****  FINAL RESULTS  ****\n');
        fprintf('*************************\n');
        fprintf(' - Overall Perceptual Score: OPS = %.f/100\n',res.OPS)
        fprintf(' - Target-related Perceptual Score: TPS = %.f/100\n',res.TPS)
        fprintf(' - Interference-related Perceptual Score: IPS = %.f/100\n',res.IPS)
        fprintf(' - Artifact-related Perceptual Score: APS = %.f/100\n',res.APS);
    end
end

%% BSS Eval back-end
if(BSS_EVAL_BACK_END)
    disp('Evaluation of results using BSS EVAL');
    estSrc = zeros(2,nsampl,I);
    
    for j =1:J
        estSrc(j,:,:) = audioread([results_dir 'EstimatedSource_' num2str(j) '.wav']);
    end
    [SDR,ISR,SIR,SAR,perm]=bss_eval_images(estSrc,Src_Image);
    fprintf(['Source 1 / 2 SDR : ' num2str(SDR(1)) ' dB / ' num2str(SDR(2)) ' dB\n']);
    fprintf(['Source 1 / 2 ISR : ' num2str(ISR(1)) ' dB / ' num2str(ISR(2)) ' dB\n']);
    fprintf(['Source 1 / 2 SIR : ' num2str(SIR(1)) ' dB / ' num2str(SIR(2)) ' dB\n']);
    fprintf(['Source 1 / 2 SAR : ' num2str(SAR(1)) ' dB / ' num2str(SAR(2)) ' dB\n']);
end